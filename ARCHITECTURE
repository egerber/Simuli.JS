ActivationCache

tick()

increaseCache(id,length)

decrease(id, length)

get_output(id, delay)

get_feedback(id, delay);

let selection1;
let selection2;

selection1.connect(selection2, "feedforward", (i,j)=>i==j, p=0.1)

connect( (i1,i2,state1,state2)=>i1==i2 || state1.x-1 * random() < 12);

ComputationalGraph
connections:{
	id: [id1,id2,delay,type]
}

adj_in{
	"feedforward": {}.
	"feedback":{}
}

order:{
	"feedforward":[]
	"feedback":[]
}

remove(id){
	check in both feedforward and feedback
}

move_before(order, element1, element)
move_after()

alternatively:
two-lists
problem: no unique ids
	- could be managed by parent
		-> creates object with holes
