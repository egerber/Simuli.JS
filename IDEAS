.monitor_state(select("group0"), ["my_var1", "my_var2"],interval);
.monitor_state(select("group1"), ["my_var2", "my_var3"],interval);

.monitor_activation(selectAll(), "feedforward",interval);
.monitor_structure()

selector for monitor should have following options:
- select by schema -> e.g ["integrators"]
- seÄºect by group e.g. ["my_group_1"]



State_logger.add(selection, states, interval, aggregated_true)
	- if aggregated
		- saves min, max, mean, std
	or alternative: func takes array
- problem not consistent with multiple state properties
	-> one state logger per property
		- too much#


states:[
{id:10, property1: 12, property2: 255, property3: 15}]
{id:"group0, group2", property: "test", mean:12, min:0, max:100, std: 0.4}

feedforward_activations:[
	{id:1, value:12}
],
feedback_activations:[
	{id:14, value:15}
]
states: {id1:1, property: "score", value: 12}
aggregated: {id:"selection2",property: "score", value: [0,10,0,2]} //min, max, mean, std

StateLogger
- constructor(selection,properties,interval,func_apply) /
StateStatisticsLogger:
- constructor(selection, properties,interval, aggregation_func)
PopulationStateMonitor(selection,)
PopulationActivationMonitor(selection,)

Population Monitor for feedback signals does not make sense
PopulationMonitor refers to statistics about state

data:{
	name:"session_name"
	state_data:[
		{id:10, property:"test",value:12,t:12}
		...
	],
	feedforward_data:[
		{id:10, value:14, t:100},
		...
	],
	feedback_data:[],
	population_state:[
		{id: "selection1", prop:"test", min:12, max:100, mean:50, std:2}
		...
	],
	graph_data:[
		nodes:[
			{id:11, group:12,t:0
			{op:"+", id:11,t:12},
			{op:"+", id:14,t:12},
			{op:"-", id:14,t:16}
			...
		],
		links_feedforward:[
			{op:"+", id:14, source:4,target:5,del:0, t:122}
			{op:"-", id:15, t:155}
			...
		],
		links_feedback:[
			
		]
	]
}

OPt